# 6.1  进行虚拟地址空间

**程序和进程**

程序是一个静态的概念，指预先编译好的指令与数据的集合。而进行是一个动态的概念，它是程序运行时的一个过程，所以很多时候把动态库叫做运行时(Runtime)。  

每个程序运行时，都有它自己独立*虚拟地址空间（Virtual Address Space）*，这个空间的大小由计算机的硬件水平决定。
我们可以通过C语言的指针判断虚拟地址空间的大小，C指针的位数与虚拟空间的位数相同，如32位平台下的指针为32位，即4字节。以下以32位平台，4GB空间为例说明。  

当程序运行时，无法随意访问虚拟空间。因为进程的虚拟空间都在操作系统的管理中，进程只能访问被分配的空间，当进行访问未被运行的空间时，访问会被操作系统捕获，并当作非法操作，强制关闭进程。 

虚拟空间的分配大致如下图，4GB的空间被划分为两个部分，操作系统本身用去1GB，从0xC00000000D到0xFFFFFFFF。剩下的从0x00000000到0xBFFFFFFF共3GB空间是给用户使用的。

![1639577156927_2](D:\52429\Documents\Typora\picture\1639577156927_2.png)

3GB的虚拟空间只是理论上给进程使用的，实际中进程不会用到全部的3GB空间，还有一部分是预留给其他用途的。后面会有介绍。

当32 位的平台内存不足时，人们自然而然地想到将平台升级到64位，当并不是所有平台都可以顺利升级到64位，很多程序只能在32位平台下运行。那32位平台可否顺利使用超过4GB的虚拟空间呢？将在下一节PAE中介绍。

**PAE**
32位平台下，程序可否使用超过4GB的空间？
如果空间指的是虚拟空间，那是是不可以的，因为32位CPU的只能使用32位的指针。
如果指的是计算机内存，那么是可以的。
从硬件层面上，将32位地址线扩展成36位地址线后，通过修改页映射的方式，可以访问到更多的物理地址空间。Inter把这种方式叫做*PAE(Physical Address Extension)*。
其流程是操作系统提供一个窗口页映射的方法，比如应用程序中0x10000000~0x20000000这段256MB的空间来做窗口，程序可以从高于4GB的物理空间中申请多个大小为256MB的物理空间，编号A,B,C等，然后根据需要将这个窗口映射到不同的物理空间中。当然，对于应用程序而言，其能感知到的最大虚拟空间依然是4GB。

# 6.2 装载的方式

程序执行时所需的指令和数据必须在内存中才能正常运行，但是一般情况下这些程度所需的内存数量都远大于物理内存数量，而内存本身又是昂贵的，单纯靠增加内存的方式成本太高。后来人民发现程序运行有局部性原理，所以可以将程序最常用的部分装载进内存，其他的部分保存在磁盘中，等待程序调用时再装载。这就是动态装载的基本原理。
*覆盖装入（Overlay）*和*页映射（Paging）*是两种典型的动态装载方法。

## 6.2.1 覆盖装入 Overlay

覆盖装入流行于虚拟存储被发明之前，它将挖掘内存潜力的任务交给了程序员，程序员在编写程序时必须手动地将程序分割为若干块。然后编写辅助代码来管理这些模块，这个辅助代码就是覆盖管理器（Overlay Manager）。
最简单的情况下，一个程序有主模块main和A，B两个模块，且AB之间没有相互调用，三个模块的大小为1024字节，512字节，256字节。在不考虑内存对齐，装载地址限制的情况下，总共需要1792字节的空间。但由于AB之间没有相互调用，可以采用以下的装载方式：

![1639577157284_3](D:\52429\Documents\Typora\picture\1639577157284_3.png)

当main调用A模块时，覆盖管理器将A模块装入内存；当main调用B模块时，将B装入原来A所占用的内存空间中，除了覆盖管理器，比之前节省了256字节。而当面对多个复杂调用的模块时，程序员需要手工*将模块按照他们之前的调用关系组织成树状结构*。

![1639577157644_4](D:\52429\Documents\Typora\picture\1639577157644_4.png)

此时覆盖管理器需要注意两点：
1.树状结构从任何一个模块到根，也就是main，都叫做调用路径。当该模块被调用时，调用路径上的所有模块都必须装载在内存中。
2.禁止跨树间调用。任意一个模块不允许跨过树间结构，而当一个模块被多个不同分支的模块调用时，最简单的方法是将其装载进main模块。

## 6.2.2 页映射 Paging

页映射是虚拟存储的一部分。简单来讲，就是讲内存和磁盘中的所有指令和数据按照"页"为单位划分成若干页，目前的硬件规定页一般有4096字节，8192字节，2MB,4MB等。按照装载的局部性原理，在装载的过程中，有一个装载管理器，按照程序调用的先后顺序和模块的调用次数，将不同的模块装入到不同的页中；当内存不足时，将暂不使用的页装载进新的指令和数据。
目前所有主流的操作系统都安装这种方式装载文件。

# 6.3 从操作系统角度看可执行文件的装载

从操作系统角度看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他的进程。创建一个进程并开始执行，需要有以下的三个步骤：
*1.创建一个独立的虚拟地址空间*

# 6.3.1 进程的建立

一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理页，因此创建一个虚拟空间并不是要创建空间，而是创建映射函数所需要的相应的数据结构。在linux下，创建虚拟空间实际上只需要分配一个页目录就可以了。

*2.读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。*
上一步是映射关系函数是虚拟内存空间到物理内存的映射关系，而这一步则是虚拟内存到可执行文件的映射关系。可以说这一步就是装载的最重要的一步，也是传统理解上装载的过程。
很明显，这种关系只是保存在操作系统内部的一个数据结构。Linux将进程虚拟空间中的一个段叫做虚拟内存区域(VMA,Virtual Memory Area);在windows中，这个叫做虚拟段(Virtual Section).
*3.将CPU的指令寄存器设置成可执行文件的入口地址，启动运行*
这一步从进程的角度看最为简单，就是操作系统将通过设置CPU的指令寄存器将控制权交给进程。或者可以简单的看成操作系统执行了一条跳转指令，直接跳转到ELF文件问保存的可执行文件入口地址。

*由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件。*

# 6.3.2 页错误 Page Fault

页错误并不是指程序运行发生了错误，而是说在执行完进程建立的步骤后，程序和数据还没有被真正装载进内存中，当CPU开始执行可执行文件入口地址的指令时，会发现这是一个空页面，于是它认为这是一个页错误，并将控制权交还给操作系统，操作系统通过查询虚拟空间与可执行文件映射的数据结构，然后找到空页所在的VMA，计算出相应页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页面建立映射关系，再将控制权返还给进程，进程就从刚才发送页错误的位置重新开始执行。随着进行的运行，页错误也会不断发生，操作系统也就会不断为进行分配新的物理页面。

# 6.4 进程虚存空间分布

# 6.4.1 ELF文件链接视图和执行视图





